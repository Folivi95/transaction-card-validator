// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/saltpay/transaction-card-validator/internal/application/ports"
	"sync"
)

// Ensure, that MetricsClientMock does implement ports.MetricsClient.
// If this is not the case, regenerate this file with moq.
var _ ports.MetricsClient = &MetricsClientMock{}

// MetricsClientMock is a mock implementation of ports.MetricsClient.
//
// 	func TestSomethingThatUsesMetricsClient(t *testing.T) {
//
// 		// make and configure a mocked ports.MetricsClient
// 		mockedMetricsClient := &MetricsClientMock{
// 			CountFunc: func(name string, value int64, tags []string)  {
// 				panic("mock out the Count method")
// 			},
// 			HistogramFunc: func(name string, value float64, tags []string)  {
// 				panic("mock out the Histogram method")
// 			},
// 		}
//
// 		// use mockedMetricsClient in code that requires ports.MetricsClient
// 		// and then make assertions.
//
// 	}
type MetricsClientMock struct {
	// CountFunc mocks the Count method.
	CountFunc func(name string, value int64, tags []string)

	// HistogramFunc mocks the Histogram method.
	HistogramFunc func(name string, value float64, tags []string)

	// calls tracks calls to the methods.
	calls struct {
		// Count holds details about calls to the Count method.
		Count []struct {
			// Name is the name argument value.
			Name string
			// Value is the value argument value.
			Value int64
			// Tags is the tags argument value.
			Tags []string
		}
		// Histogram holds details about calls to the Histogram method.
		Histogram []struct {
			// Name is the name argument value.
			Name string
			// Value is the value argument value.
			Value float64
			// Tags is the tags argument value.
			Tags []string
		}
	}
	lockCount     sync.RWMutex
	lockHistogram sync.RWMutex
}

// Count calls CountFunc.
func (mock *MetricsClientMock) Count(name string, value int64, tags []string) {
	if mock.CountFunc == nil {
		panic("MetricsClientMock.CountFunc: method is nil but MetricsClient.Count was just called")
	}
	callInfo := struct {
		Name  string
		Value int64
		Tags  []string
	}{
		Name:  name,
		Value: value,
		Tags:  tags,
	}
	mock.lockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	mock.lockCount.Unlock()
	mock.CountFunc(name, value, tags)
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//     len(mockedMetricsClient.CountCalls())
func (mock *MetricsClientMock) CountCalls() []struct {
	Name  string
	Value int64
	Tags  []string
} {
	var calls []struct {
		Name  string
		Value int64
		Tags  []string
	}
	mock.lockCount.RLock()
	calls = mock.calls.Count
	mock.lockCount.RUnlock()
	return calls
}

// Histogram calls HistogramFunc.
func (mock *MetricsClientMock) Histogram(name string, value float64, tags []string) {
	if mock.HistogramFunc == nil {
		panic("MetricsClientMock.HistogramFunc: method is nil but MetricsClient.Histogram was just called")
	}
	callInfo := struct {
		Name  string
		Value float64
		Tags  []string
	}{
		Name:  name,
		Value: value,
		Tags:  tags,
	}
	mock.lockHistogram.Lock()
	mock.calls.Histogram = append(mock.calls.Histogram, callInfo)
	mock.lockHistogram.Unlock()
	mock.HistogramFunc(name, value, tags)
}

// HistogramCalls gets all the calls that were made to Histogram.
// Check the length with:
//     len(mockedMetricsClient.HistogramCalls())
func (mock *MetricsClientMock) HistogramCalls() []struct {
	Name  string
	Value float64
	Tags  []string
} {
	var calls []struct {
		Name  string
		Value float64
		Tags  []string
	}
	mock.lockHistogram.RLock()
	calls = mock.calls.Histogram
	mock.lockHistogram.RUnlock()
	return calls
}
